comment "//" ;  --sembra non ci siano commenti in una linea
comment "/*" "*/" ; -- commento multilinea con doppio asterisco

entrypoints Program, Stmt, RExpr, LExpr ;

rules Boolean ::= "true" | "false" ;
rules EndLine ::= ";" | "\n" ;
rules BasicType ::= "bool" | "char" | "string" | "float" | "int" | "void" ;

-- RExpressions

coercions   RExpr 14 ;

-- Boolean Operators
ExprOr.         RExpr ::= RExpr "||" RExpr1 ;
ExprAnd.        RExpr1 ::= RExpr1 "&&" RExpr2 ;
ExprNot.        RExpr2 ::= "!" RExpr3 ;

-- Comparison Operators
ExprEq.         RExpr5 ::= RExpr6 "==" RExpr6 ;
ExprNeq.        RExpr5 ::= RExpr6 "!=" RExpr6 ;

-- Partial Ordering operators
ExprLt.         RExpr5 ::= RExpr6 "<"  RExpr6 ;
ExprLtEq.        RExpr5 ::= RExpr6 "<=" RExpr6 ;
ExprGt.         RExpr5 ::= RExpr6 ">"  RExpr6 ;
ExprGtEq.        RExpr5 ::= RExpr6 ">=" RExpr6 ;
--; arithmetic equality 3 <=> 3.0 -> true
--;TODO AsBigAs.        RExpr5 ::= RExpr6 "<=>" RExpr6 ;
 
--;TODO Interval operators
--; IntInc.   RExpr_ ::= RExpr_ ".." RExpr_;
--; IntExc.   RExpr_ ::= RExpr_ ".!" RExpr_;

--;TODO Shift operators
--; ShiftL.   RExpr_ ::= RExpr_ "<<" RExpr_;
--; ShiftR.   RExpr_ ::= RExpr_ ">>" RExpr_;

-- Aritmetic operators
ExprPlus.       RExpr7 ::= RExpr7 "+" RExpr8 ;
ExprMinus.      RExpr7 ::= RExpr7 "-" RExpr8 ;
ExprMul.        RExpr8 ::= RExpr8 "*" RExpr9 ;
ExprFloatDiv.   RExpr8 ::= RExpr8 "/" RExpr9 ;
ExprIntDiv.     RExpr8 ::= RExpr8 "//" RExpr9 ;
ExprReminder.   RExpr8 ::= RExpr8 "%" RExpr9 ;
ExprModulo.     RExpr8 ::= RExpr8 "%%" RExpr9;
--;TODO ModExp.        RExpr_ ::= RExpr_ "**" RExpr_ "%%" RExpr_ ;
ExprPower.      RExpr9 ::= RExpr10 "**" RExpr9 ;

-- Unary prefix
ExprNegation.    RExpr11 ::= "-" RExpr12 ;
ExprReference.   RExpr11 ::= "&" LExpr ;
--; TODO BinCom RExpr_ ::= "~" LExpr ;

-- Function Call
ExprFunCall.     RExpr12 ::= FunCall ;

-- Data Types
ExprInt.        RExpr13 ::= Integer ;
ExprChar.       RExpr13 ::= Char ;
ExprString.     RExpr13 ::= String ;
ExprFloat.      RExpr13 ::= Double ;
ExprBool.       RExpr13 ::= Boolean ;

LExpr.      RExpr14 ::= LExpr ;

ExprFunCall.       FunCall ::= Ident "(" [RExpr] ")" ;

separator   RExpr "," ;


-- Pre/Post Increment/Decrement
ExprPreInc.     LExpr ::= "++" LExpr1 ;
ExprPreDecr.    LExpr ::= "--" LExpr1 ;

ExprPostInc.    LExpr1 ::= LExpr2 "++" ;
ExprPostDecr.   LExpr1 ::= LExpr2 "--" ;

--BasLExpr.  	LExpr2 ::= BLExpr ;

--ArrayEl.   	BLExpr ::= BLExpr "[" RExpr "]" ;
--Id.         BLExpr ::= Ident ;
--ExprDeref.      BLExpr ::= "*" BLExpr ;



PDefs.       Program ::= [Decl] ;

-- Declarations
separator   Decl "" ;


-- TODO insert an OPTIONAL guard befor := to define return type
--; :any -> any type
--; :void -> procedure
--; :type -> specific type
--; def pattern guard := init-expression
DeclVar.       Decl ::= "var" Ident TypeSpec EndLine ;
DeclVarAssign. Decl ::= "var" Ident BasicType ":=" RExpr EndLine ;
-- TODO insert list_pattern assignement, example:
-- def/var [var1, var2] := expression
-- def define the constant (definitive) value for a variable
DeclConst.     Decl ::= "def" Ident BasicType "=" RExpr EndLine ;
-- BEWARE: E should allow cyclic definition
-- def a := [1, a, 3] -> [1, [1, [1, ..., 3], 3], 3]


-- TODO insert a guard befor body to define return type
-- :any -> any type
-- :void -> procedure
-- :type -> specific type
-- functions:	 	def name(patterns) guard { body }
Dfun.       Decl ::= "def" Ident "(" [Parameter] ")" CompStmt ;

BasTyp.     TypeSpec ::= BasicType ;

CompType.   TypeSpec ::= CompoundType ;
ArrDef.     CompoundType ::= "[" RExpr "]" TypeSpec ;
ArrUnDef.   CompoundType ::= "["  "]" TypeSpec ;
Pointer.    CompoundType ::= "*" TypeSpec ;

separator   Parameter "," ;


--TODO insert a guard after parameter identifier
-- def makePurse(var balance :(int >= 0)) :any{...}
Param.      Parameter  ::= Modality Ident ;
--Guard.      Guard      ::= ":"
rules       Modality   ::= {-empty-} | "var";


BlockDecl.  CompStmt ::= "{" [Decl] [Stmt] "}" ;

separator Stmt "" ;

-- Statements
Comp.       Stmt ::= CompStmt ;
ProcCall.   Stmt ::= FunCall EndLine ;
-- Jmp.        Stmt ::= JumpStmt EndLine ;
Iter.       Stmt ::= IterStmt ;
Sel.        Stmt ::= SelectionStmt ;
Assgn.      Stmt ::= LExpr Assignment_op RExpr EndLine ;
LExprStmt.  Stmt ::= LExpr EndLine ;

--TODO evenutally assignement AssignEv.   Assignment_op ::= "<-" ;
Assign.      Assignment_op ::= ":=" ;
AssgnOr.     Assignment_op ::= "|=" ;
AssgnAnd.    Assignment_op ::= "&=" ;
-- ;TODO AssgnShL.    Assignment_op ::= "<<=" ;
-- ;?? Assgn__.   Assignment_op ::= "^=" ;
AssgnAdd.    Assignment_op ::= "+=" ;
AssgnSub.    Assignment_op ::= "-=" ;
AssgnMul.    Assignment_op ::= "*=" ;
AssgnDiv.    Assignment_op ::= "/=" ;
AssgnDivInt. Assignment_op ::= "//=" ;
AssgnRem.    Assignment_op ::= "%=" ;
AssgnMod.    Assignment_op ::= "%%=" ;
AssgnPow.    Assignment_op ::= "**=" ;
-- TODO AssgnShR.    Assignment_op ::= ">>=" ;

-- Not found in language
-- Break.      JumpStmt ::= "break" ;
-- Continue.   JumpStmt ::= "continue" ;


IfNoElse.   SelectionStmt ::= "if" "(" RExpr ")" CompStmt ;
IfElse.     SelectionStmt ::= "if" "(" RExpr ")" CompStmt "else" CompStmt ;
Switch.     SelectionStmt ::= "switch" RExpr "match" [SwitchLabel] "default" CompStmt ;
SwitchL.    SwitchLabel ::= RExpr CompStmt ;

separator SwitchLabel "" ;


While.      IterStmt ::= "while" RExpr CompStmt ;
DoWhile.    IterStmt ::= "do" CompStmt "while" RExpr ";" ;
For.        IterStmt ::= "for" Ident "in" RExpr CompStmt ;
