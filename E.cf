-- Position tokens: ((row,column), token).
position token PTrue 't' 'r' 'u' 'e' ;							-- true
position token PFalse 'f' 'a' 'l' 's' 'e' ;						-- false
position token PReturn 'r' 'e' 't' 'u' 'r' 'n' ;				-- return
position token PContinue 'c' 'o' 'n' 't' 'i' 'n' 'u' 'e' ;		-- continue
position token PBreak 'b' 'r' 'e' 'a' 'k' ;						-- break
position token PIdent (letter (letter | digit | '_' | '\'')*) ;	-- function and variable names
position token PInteger digit+ ;								-- integer
position token PFloat digit+ '.' digit+ ;						-- float
position token PChar '\'' char '\'' ;							-- char
position token PString '"' char+ '"' ;							-- string

-- A program is a sequence of declarations.
PDefs.     Program ::= [Decl] ;
terminator Decl "" ;


-- Include in the abstract syntax a type annotated version of expressions.
--internal ExprTyped. Expr ::= "[" Type "]" Expr ;
--PTDefs. Program ::=  [AnnotatedDecl] ;
--terminator AnnotatedDecl "";


-- An annotated declaration is a declaration.
internal TypedDecl. Decl ::= AnnotatedDecl ;


-- A program may containt (C-like) comments, which are ignored by the parser.
comment "#" ;
comment "/*" "*/" ;


-- Function declaration. E.g.: def foo (int x, float y) : int { }
DeclFun.   Decl          ::= "def" LExpr "(" [Arg] ")" Guard CompStmt ;
ADecl.     AnnotatedDecl ::= "["Type ":]" Decl ;
separator  Arg "," ;
--terminator Stmt "" ;


-- An argument declaration has a type and an identifier.
ArgDecl.   Arg      ::= Modality PIdent Guard ;
ModEmpty.  Modality ::= {-empty-} ;  -- no modality
ModVar.    Modality ::= "var" ;      -- variable modality
ModDef.    Modality ::= "def" ;      -- constant modality


-- Guards of declarations. E.g.: 
-- def i : <guard>; 
-- def foo (i : <guard>) : <guard> {}
GuardVoid.  Guard ::= {-empty-} ;  -- empty guard
GuardType.  Guard ::= ":" Type ;   -- guarded

-- Any Expression followed by a semicolon ; can be used as a statement.
StmtExpr.       Stmt     ::= Expr ";" ;

--StmtVarDecl.         Stmt     ::= "var" PIdent Guard ";" ;                   -- Variable declaration.
StmtVarInit.         Stmt     ::= "var" PIdent Guard ":=" Expr ";" ;         -- Variable initialization.
--StmtVarArrDeclNoDim. Stmt     ::= "var" "[" "]" LExpr Guard ";" ;           -- Variable array without dimension declaration.
--StmtVarArrDecl.      Stmt     ::= "var" "[" Expr "]" LExpr Guard ";" ;     	-- Variable array with dimension declaration.
StmtVarArrInit. Stmt ::= "var" "[" [PInteger] "]" PIdent Guard ":=" Array ";" ; -- Variable array initialization.


--StmtDefDecl.         Stmt     ::= "def" PIdent Guard ";" ;                   -- Constant declaration.
StmtDefInit.         Stmt     ::= "def" PIdent Guard ":=" Expr ";" ;         -- Constant initialization.
--StmtDefArrDeclNoDim. Stmt     ::= "def" "[" "]" LExpr Guard ";" ;           -- Constant array without dimension declaration.
--StmtDefArrDecl.      Stmt     ::= "def" "[" Expr "]" LExpr Guard ";" ;      -- Constant array with dimension declaration.
StmtDefArrInit. Stmt ::= "def" "[" [PInteger] "]" PIdent Guard ":=" Array ";" ; -- Constant array initialization.

ExprArray.      Array ::= Expr ;
ExprMultiArray. Array ::= "[" [Array] "]" ;
separator Array "," ;

--ExprRange.           Range ::= PInteger ;
separator PInteger "," ;

StmtReturn.     Stmt     ::= PReturn "(" Expr ")" ";" ;
StmtNoReturn.   Stmt     ::= PReturn ";" ;


StmtBlock.      CompStmt ::= "{" [Decl] "}" ;
SComp.          Stmt ::= CompStmt ;


StmtIfThenElse. Stmt     ::= "if" "(" Expr ")" CompStmt "else" CompStmt ;
StmtIfThen.     Stmt     ::= "if" "(" Expr ")" CompStmt ;
StmtSwitchCase.    Stmt     ::= "switch" "(" Expr ")" "{" [NormCase] [DfltCase] "}" ;
CaseNormal.     NormCase ::= "match" Expr CompStmt ;
CaseDefault.    DfltCase ::= "match _" CompStmt ;
separator NormCase "" ;
separator DfltCase "" ;
StmtBreak.      Stmt     ::= PBreak ";" ;
StmtContinue.   Stmt     ::= PContinue ";" ;

StmtWhile.      Stmt     ::= "while" "(" Expr ")" CompStmt ;
StmtFor.        Stmt     ::= "for" PIdent "in" Range CompStmt ;
ExprRange.      Range    ::= ForId ".." ForId ;
ForIdent.       ForId    ::= PIdent ;
ForInteger.     ForId    ::= PInteger ;          

ExprAssign.     Expr     ::= LExpr  AssignOperator  Expr1  ;


-- A statement is a declaration.
DeclStmt.       Decl ::= Stmt ;


-- (Left) Expressions
LExprId.        LExpr ::= PIdent ;
--LExprDeref.     LExpr ::= Deref ;
LExprRef.       LExpr ::= Ref ;
LExprArr.       LExpr ::= Arr ;
-- # 1 shift/reduce conflict with Arr
-- # when I read a LExpr followed by a "[" I shift to read a LArrExpr
-- # (The reducing rule is used after reading all that rule)
--LDerefExpr.     Deref ::= "&" LExpr;
-- # 1 shift/reduce conflict
-- # same as before
LRefExpr.       Ref   ::= "*" LExpr;
--LArrExpr.       Arr   ::= PIdent "[" Expr "]"; -- Changing PIdent with LExpr => +2 s/r conflicts
LArrExpr. Arr ::= PIdent "[" AExpr "]" ;         -- How we access an array element.

ArrSing. AExpr ::= PInteger ;
ArrMul.  AExpr ::= AExpr "," PInteger ;
--coercions LExpr 1;
--_. LExpr ::= "(" LExpr ")" ;

-- (Right) Expressions
ExprLeft.     Expr17 ::= LExpr ;
ExprInt.      Expr16 ::= PInteger ;
ExprFloat.    Expr16 ::= PFloat ;
ExprChar.     Expr16 ::= PChar ;
ExprString.   Expr16 ::= PString ;
ExprTrue.     Expr16 ::= PTrue ;
ExprFalse.    Expr16 ::= PFalse ;

ExprFunCall.  Expr15 ::= PIdent "(" [Expr] ")" ;

ExprBoolNot.  Expr14  ::= "!" Expr15 ;

ExprNegation. Expr14  ::= "-" Expr15 ;
ExprAddition. Expr14  ::= "+" Expr15 ;

ExprPower.    Expr13 ::= Expr14 "^"  Expr13 ;

ExprMul.      Expr12 ::= Expr12 "*"  Expr13 ;
ExprFloatDiv. Expr12 ::= Expr12 "/"  Expr13 ;
ExprIntDiv.   Expr12 ::= Expr12 "//" Expr13 ;
ExprReminder. Expr12 ::= Expr12 "%"  Expr13 ;
ExprModulo.   Expr12 ::= Expr12 "%%" Expr13 ;

ExprReference. Expr11 ::= "&" LExpr ;
ExprPlus.      Expr11 ::= Expr11 "+"  Expr12 ;
ExprMinus.     Expr11 ::= Expr11 "-"  Expr12 ;

-- Tolti per ridurre i conflitti reduce reduce con Array
-- Potrebbero essere richiesti
-- ExprIntInc.   Expr10 ::= Expr10 ".."  Expr11 ;
-- ExprIntExc.   Expr10 ::= Expr10 "..!" Expr11 ;

ExprLt.       Expr9  ::= Expr9  "<"   Expr10 ;
ExprGt.       Expr9  ::= Expr9  ">"   Expr10 ;
ExprLtEq.     Expr9  ::= Expr9  "<="  Expr10 ;
ExprGtEq.     Expr9  ::= Expr9  ">="  Expr10 ;

ExprEq.       Expr8  ::= Expr8  "=="  Expr9 ;
ExprNeq.      Expr8  ::= Expr8  "!="  Expr9 ;

ExprAnd.      Expr4  ::= Expr4  "&&"  Expr5 ;

ExprOr.       Expr3  ::= Expr3  "||"  Expr4 ;


coercions Expr 17 ;
separator Expr "," ;


-- Assignment operators (i.e., l-value operator r-value).
OpAssign.     AssignOperator ::= ":=" ;
OpOr.         AssignOperator ::= "|=" ;
OpAnd.        AssignOperator ::= "&=" ;
OpPlus.       AssignOperator ::= "+=" ;
OpMinus.      AssignOperator ::= "-=" ;
OpMul.        AssignOperator ::= "*=" ;
OpIntDiv.     AssignOperator ::= "//=" ;
OpFloatDiv.   AssignOperator ::= "/=" ;
OpRemainder.  AssignOperator ::= "%=" ;
OpModulo.     AssignOperator ::= "%%=" ;
OpPower.      AssignOperator ::= "^=" ;


-- The available type are bool, double, int, void, char and string.
TypeBool.   Type ::= "bool" ;
TypeFloat.  Type ::= "float" ;
TypeInt.    Type ::= "int" ;
TypeVoid.   Type ::= "void" ; 
TypeChar.   Type ::= "char" ;
TypeString. Type ::= "string" ; 
--TypeAny.    Type ::= "any" ;


-- Compound types.
TypeCompound. Type  ::= CType ;
TypePointer.  CType ::= Type "*" ; 					-- Pointer type.
TypeAddress.  CType ::= Type "&" ;					-- Address type.
TypeArray.    CType ::= Type "[" [PInteger] "]" ;		-- Array type.


--TypeExprArray. Array ::= Expr ;           -- Iterable interval.
--TypeArrayArray.    Array ::= "[" [Expr] "]" ;   -- Iterable array.
--TypeMultiArray.   Array ::= "[" [Array] "]" ;   -- Iterable array.
--separator Array "," ;


-- The entry point is the program.
entrypoints Program ;
