-- Position tokens: ((row,column), token).
position token PTrue 't' 'r' 'u' 'e' ;							-- true
position token PFalse 'f' 'a' 'l' 's' 'e' ;						-- false
position token PReturn 'r' 'e' 't' 'u' 'r' 'n' ;				-- return
position token PContinue 'c' 'o' 'n' 't' 'i' 'n' 'u' 'e' ;		-- continue
position token PBreak 'b' 'r' 'e' 'a' 'k' ;						-- break
position token PIdent (letter (letter | digit | '_' | '\'')*) ;	-- function and variable names
position token PInteger digit+ ;								-- integer
position token PFloat digit+ '.' digit+ ;						-- float
position token PChar '\'' char '\'' ;							-- char
position token PString '"' char+ '"' ;							-- string

-- A program is a sequence of declarations.
PDefs.     Program ::= [Decl] ;
terminator Decl "" ;


-- Include in the abstract syntax a type annotated version of expressions.
--internal ExprTyped. Expr ::= "[" Type "]" Expr ;
--PTDefs. Program ::=  [AnnotatedDecl] ;
--terminator AnnotatedDecl "";


-- An annotated declaration is a declaration. Using the 'internal' keyword will force the parser to ignore such rule, and we use it to print the annotated tree.
internal TypedDecl. Decl ::= AnnotatedDecl ;


-- A program may containt (C-like) comments, which are ignored by the parser.
comment "#" ;
comment "/*" "*/" ;


-- Function declaration. E.g.: def foo (int x, float y) : int { }
DeclFun.   Decl          ::= "def" LExpr "(" [Arg] ")" Guard CompStmt ;
ADecl.     AnnotatedDecl ::= "["Type ":]" Decl ;
separator  Arg "," ;
--terminator Stmt "" ;


-- An argument declaration has a type and an identifier.
ArgDecl.   Arg      ::= Modality PIdent Guard ;
ModEmpty.  Modality ::= {-empty-} ;  -- no modality
ModVar.    Modality ::= "var" ;      -- variable modality
ModDef.    Modality ::= "def" ;      -- constant modality


-- Guards of declarations. E.g.: 
-- def i : <guard>; 
-- def foo (i : <guard>) : <guard> {}
GuardVoid.  Guard ::= {-empty-} ;  -- empty guard
GuardType.  Guard ::= ":" Type ;   -- guarded

-- Any Expression followed by a semicolon ; can be used as a statement.
StmtExpr.       Stmt     ::= Expr ";" ;


StmtVarInit.         Stmt     ::= "var" PIdent Guard ":=" ComplexExpr ";" ;         -- Variable initialization.
StmtDefInit.         Stmt     ::= "def" PIdent Guard ":=" ComplexExpr ";" ;         -- Constant initialization.

--StmtVarArrInit. Stmt ::= "var" PIdent Guard ":=" "[" Array "]" ";" ; -- Variable array initialization.
--StmtDefArrInit. Stmt ::= "def" PIdent Guard ":=" "[" Array "]" ";" ; -- Constant array initialization.

ExprSimple.         ComplexExpr ::= Expr ;
ExprArray.          ComplexExpr ::= "[" [ComplexExpr] "]" ;
separator       nonempty ComplexExpr "," ;

--ExprArray.      Array ::= Expr ;
--ExprMultiArray. Array ::= "[" [Array] "]" ;
--separator Array "," ;
separator PInteger "," ;

StmtReturn.     Stmt     ::= PReturn "(" Expr ")" ";" ;
StmtNoReturn.   Stmt     ::= PReturn ";" ;


StmtBlock.      CompStmt ::= "{" [Decl] "}" ;
SComp.          Stmt ::= CompStmt ;


StmtIfThenElse. Stmt     ::= "if" "(" Expr ")" CompStmt "else" CompStmt ;
StmtIfThen.     Stmt     ::= "if" "(" Expr ")" CompStmt ;
StmtSwitchCase.    Stmt     ::= "switch" "(" Expr ")" "{" [NormCase] [DfltCase] "}" ;
CaseNormal.     NormCase ::= "match" Expr CompStmt ;
CaseDefault.    DfltCase ::= "match _" CompStmt ;
separator NormCase "" ;
separator DfltCase "" ;
StmtBreak.      Stmt     ::= PBreak ";" ;
StmtContinue.   Stmt     ::= PContinue ";" ;

StmtWhile.      Stmt     ::= "while" "(" Expr ")" CompStmt ;
StmtFor.        Stmt     ::= "for" PIdent "in" Range CompStmt ;
ExprRange.      Range    ::= ForId ".." ForId ;
ForIdent.       ForId    ::= PIdent ;
ForInteger.     ForId    ::= PInteger ;          

ExprAssign.     Expr     ::= LExpr  AssignOperator  Expr1  ;


-- A statement is a declaration.
DeclStmt.       Decl ::= Stmt ;


-- (Left) Expressions
LExprId.        LExpr ::= PIdent ;
--LExprDeref.     LExpr ::= Deref ;
LExprRef.       LExpr ::= Ref ;
LExprArr.       LExpr ::= Arr ;
-- # 1 shift/reduce conflict with Arr
-- # when I read a LExpr followed by a "[" I shift to read a LArrExpr
-- # (The reducing rule is used after reading all that rule)
--LDerefExpr.     Deref ::= "&" LExpr;
-- # 1 shift/reduce conflict
-- # same as before
LRefExpr.       Ref   ::= "*" LExpr;
--LArrExpr.       Arr   ::= PIdent "[" Expr "]"; -- Changing PIdent with LExpr => +2 s/r conflicts
LArrExpr. Arr ::= PIdent "[" AExpr "]" ;         -- How we access an array element.

ArrSing. AExpr ::= Expr ;
ArrMul.  AExpr ::= AExpr "," Expr ;

-- (Right) Expressions
ExprLeft.     Expr17 ::= LExpr ;
ExprInt.      Expr16 ::= PInteger ;
ExprFloat.    Expr16 ::= PFloat ;
ExprChar.     Expr16 ::= PChar ;
ExprString.   Expr16 ::= PString ;
ExprTrue.     Expr16 ::= PTrue ;
ExprFalse.    Expr16 ::= PFalse ;

ExprFunCall.  Expr15 ::= PIdent "(" [Expr] ")" ;

ExprBoolNot.  Expr14  ::= "!" Expr15 ;

ExprNegation. Expr14  ::= "-" Expr15 ;
ExprAddition. Expr14  ::= "+" Expr15 ;

ExprPower.    Expr13 ::= Expr14 "**"  Expr13 ;

ExprMul.      Expr12 ::= Expr12 "*"  Expr13 ;
ExprFloatDiv. Expr12 ::= Expr12 "/"  Expr13 ;
ExprIntDiv.   Expr12 ::= Expr12 "//" Expr13 ;
ExprReminder. Expr12 ::= Expr12 "%"  Expr13 ;
ExprModulo.   Expr12 ::= Expr12 "%%" Expr13 ;

ExprReference. Expr11 ::= "&" LExpr ;
ExprPlus.      Expr11 ::= Expr11 "+"  Expr12 ;
ExprMinus.     Expr11 ::= Expr11 "-"  Expr12 ;

-- Tolti per ridurre i conflitti reduce reduce con Array
-- Potrebbero essere richiesti
-- ExprIntInc.   Expr10 ::= Expr10 ".."  Expr11 ;
-- ExprIntExc.   Expr10 ::= Expr10 "..!" Expr11 ;

ExprLt.       Expr9  ::= Expr9  "<"   Expr10 ;
ExprGt.       Expr9  ::= Expr9  ">"   Expr10 ;
ExprLtEq.     Expr9  ::= Expr9  "<="  Expr10 ;
ExprGtEq.     Expr9  ::= Expr9  ">="  Expr10 ;

ExprEq.       Expr8  ::= Expr8  "=="  Expr9 ;
ExprNeq.      Expr8  ::= Expr8  "!="  Expr9 ;

ExprAnd.      Expr4  ::= Expr4  "&&"  Expr5 ;

ExprOr.       Expr3  ::= Expr3  "||"  Expr4 ;


coercions Expr 17 ;
separator Expr "," ;


-- Assignment operators (i.e., l-value operator r-value).
OpAssign.     AssignOperator ::= ":=" ;
OpOr.         AssignOperator ::= "|=" ;
OpAnd.        AssignOperator ::= "&=" ;
OpPlus.       AssignOperator ::= "+=" ;
OpMinus.      AssignOperator ::= "-=" ;
OpMul.        AssignOperator ::= "*=" ;
OpIntDiv.     AssignOperator ::= "//=" ;
OpFloatDiv.   AssignOperator ::= "/=" ;
OpRemainder.  AssignOperator ::= "%=" ;
OpModulo.     AssignOperator ::= "%%=" ;
OpPower.      AssignOperator ::= "**=" ;


rules Type ::= BasicType | CompoundType ;

-- The available type are bool, double, int, void, char and string.
TypeBool.   BasicType ::= "bool" ;
TypeFloat.  BasicType ::= "float" ;
TypeInt.    BasicType ::= "int" ;
TypeVoid.   BasicType ::= "void" ; 
TypeChar.   BasicType ::= "char" ;
TypeString. BasicType ::= "string" ; 


rules CompoundType ::= ArrayType | Ptr ;

ArrDefBase.  ArrayType ::= "[" [PInteger] "]" BasicType ;
ArrDefPtr.   ArrayType ::= "[" [PInteger] "]" Ptr ;

Pointer.         Ptr       ::= BasicType "*" ;
Pointer2Pointer. Ptr       ::= Ptr "*" ;

-- Compound types.
--TypeCompound. Type  ::= CType ;
--TypePointer.  CType ::= Type "*" ; 					-- Pointer type.
--TypeArray.    CType ::= Type "[" [PInteger] "]" ;		-- Array type.


-- The entry point is the program.
entrypoints Program ;
